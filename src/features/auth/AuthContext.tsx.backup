import React, { createContext, useContext, useState, useEffect, useRef } from 'react'
import { supabase } from '@/lib/supabase'
import type { Session, User as SupabaseUser } from '@supabase/supabase-js'
import type { Tables } from '@/lib/database.types'

type UserProfile = Tables<'users'>

interface AuthContextType {
  user: SupabaseUser | null
  profile: UserProfile | null
  organization: Tables<'organizations'> | null
  session: Session | null
  loading: boolean
  signIn: (email: string, password: string) => Promise<{ error: Error | null }>
  signUp: (email: string, password: string, fullName: string, organizationName?: string) => Promise<{ error: Error | null }>
  signOut: () => Promise<void>
  updateProfile: (updates: Partial<UserProfile>) => Promise<{ error: Error | null }>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<SupabaseUser | null>(null)
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [organization, setOrganization] = useState<Tables<'organizations'> | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)
  const initialLoadComplete = useRef(false)

  // Load user profile and organization - BUT DON'T DIE IF IT FAILS
  const loadUserData = async (userId: string, userEmail?: string) => {
    console.log(`[DEBUG] loadUserData: Called for userId: ${userId}, email: ${userEmail}`);
    try {
      console.log(`[DEBUG] loadUserData: Attempting to fetch profile for userId: ${userId}`);
      // Try to get user profile
      const { data: profileData, error: profileError } = await supabase
        .from('users')
        .select('*')
        .eq('id', userId)
        .single()

      if (profileError) {
        console.warn(`[DEBUG] loadUserData: Profile not found for userId: ${userId}. Error: `, profileError);
        console.log("[DEBUG] loadUserData: Creating default profile.");
        // Just use a default profile - WHO CARES, LET THEM USE THE APP
        const defaultProfile = {
          id: userId,
          email: userEmail || 'user@example.com',
          full_name: userEmail?.split('@')[0] || 'User',
          organization_id: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
          role: 'ringer' as const,
          settings: {},
          phone: null,
          last_active: new Date().toISOString(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
        setProfile(defaultProfile as any);
        console.log("[DEBUG] loadUserData: Default profile set:", defaultProfile);
        
        // Try to get organization anyway
        console.log(`[DEBUG] loadUserData: Attempting to fetch organization for default profile. Org ID: ${defaultProfile.organization_id}`);
        try {
          const { data: orgData, error: orgError } = await supabase
            .from('organizations')
            .select('*')
            .eq('id', defaultProfile.organization_id)
            .single()
          setOrganization(orgData || null);
          console.log(`[DEBUG] loadUserData: Organization fetched for default profile. Data: `, orgData, "Error:", orgError);
        } catch (e) {
          console.warn(`[DEBUG] loadUserData: Organization load failed for default profile. Error: `, e);
        }
      } else {
        setProfile(profileData);
        console.log(`[DEBUG] loadUserData: Profile fetched successfully for userId: ${userId}. Data: `, profileData);
        
        // Try to get organization
        if (profileData?.organization_id) {
          console.log(`[DEBUG] loadUserData: Attempting to fetch organization for profile. Org ID: ${profileData.organization_id}`);
          try {
            const { data: orgData, error: orgError } = await supabase
              .from('organizations')
              .select('*')
              .eq('id', profileData.organization_id)
              .single()
            setOrganization(orgData || null);
            console.log(`[DEBUG] loadUserData: Organization fetched for profile. Data: `, orgData, "Error:", orgError);
          } catch (e) {
            console.warn(`[DEBUG] loadUserData: Organization load failed for profile. Error: `, e);
          }
        } else {
          console.log(`[DEBUG] loadUserData: No organization_id found in profile for userId: ${userId}`);
        }
      }

      // Try to update last active, but don't care if it fails
      console.log(`[DEBUG] loadUserData: Attempting to update last_active for userId: ${userId}`);
      try {
        const { error: updateError } = await supabase
          .from('users')
          .update({ last_active: new Date().toISOString() })
          .eq('id', userId)
        if (updateError) {
          console.warn(`[DEBUG] loadUserData: Could not update last_active for userId: ${userId}. Error: `, updateError);
        } else {
          console.log(`[DEBUG] loadUserData: last_active updated successfully for userId: ${userId}`);
        }
      } catch (e) {
        console.warn(`[DEBUG] loadUserData: Exception while updating last_active for userId: ${userId}. Error: `, e);
      }
        
    } catch (error) {
      console.error(`[DEBUG] loadUserData: Unexpected error for userId: ${userId}. Error: `, error);
      // STILL SET A DEFAULT PROFILE SO THE APP WORKS
      setProfile({
        id: userId,
        email: userEmail || 'user@example.com',
        full_name: 'User',
        organization_id: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
        role: 'ringer',
        settings: {},
        phone: null,
        last_active: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      } as any)
    }
  }

  useEffect(() => {
    let mounted = true
    setLoading(true)
    initialLoadComplete.current = false
    console.log('ðŸ” [DEBUG] AuthContext: useEffect triggered, initialLoadComplete set to false, setLoading(true)')

    // FAILSAFE: If still loading after 5 seconds, just stop
    const timeout = setTimeout(() => {
      console.log(`[DEBUG] AuthContext: Failsafe timeout reached. Mounted: ${mounted}, Loading: ${loading}, initialLoadComplete: ${initialLoadComplete.current}`);
      if (mounted && loading && !initialLoadComplete.current) {
        console.error('ðŸš¨ [DEBUG] AuthContext: Initial loading timeout - forcing loading to false')
        setLoading(false)
      } else if (mounted && loading) {
        // This case might indicate a subsequent loading phase that timed out
        console.error('ðŸš¨ [DEBUG] AuthContext: Subsequent loading timeout - forcing loading to false')
        setLoading(false)
      }
    }, 5000)

    // Listen for auth changes
    console.log("[DEBUG] AuthContext: Setting up onAuthStateChange listener.");
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      console.log(`[DEBUG] AuthContext: onAuthStateChange event: ${event}, Session present: ${!!session}`, { event, session });
      
      if (!mounted) {
        console.log("[DEBUG] AuthContext: onAuthStateChange - component not mounted, returning.");
        return;
      }
      
      setSession(session);
      setUser(session?.user ?? null);
      console.log("[DEBUG] AuthContext: onAuthStateChange - session and user state updated.", { session, user: session?.user });
      
      if (session?.user) {
        console.log(`ðŸ” [DEBUG] AuthContext: onAuthStateChange - Session user found (ID: ${session.user.id}), loading user data...`);
        await loadUserData(session.user.id, session.user.email);
        console.log("[DEBUG] AuthContext: onAuthStateChange - loadUserData completed.");
        if (mounted && !initialLoadComplete.current) {
          console.log(`ðŸ” [DEBUG] AuthContext: onAuthStateChange - Initial loadUserData complete, setting loading to false, initialLoadComplete to true.`);
          setLoading(false);
          initialLoadComplete.current = true;
        } else {
          console.log(`[DEBUG] AuthContext: onAuthStateChange - Load complete but either not mounted or initial load already done. Mounted: ${mounted}, initialLoadComplete: ${initialLoadComplete.current}`);
        }
      } else {
        console.log(`ðŸ” [DEBUG] AuthContext: onAuthStateChange - No session user. Clearing profile/org.`);
        setProfile(null);
        setOrganization(null);
        if (mounted && !initialLoadComplete.current) {
          console.log("[DEBUG] AuthContext: onAuthStateChange - No session user & initial load not complete. Setting loading to false, initialLoadComplete to true.");
          setLoading(false);
          initialLoadComplete.current = true;
        } else {
           console.log(`[DEBUG] AuthContext: onAuthStateChange - No session user, but either not mounted or initial load already done. Mounted: ${mounted}, initialLoadComplete: ${initialLoadComplete.current}`);
        }
      }
    });

    return () => {
      mounted = false;
      clearTimeout(timeout);
      console.log("[DEBUG] AuthContext: useEffect cleanup. Unsubscribing from onAuthStateChange.");
      if (subscription) {
        subscription.unsubscribe();
      }
      console.log(`ðŸ” [DEBUG] AuthContext: useEffect cleanup complete.`);
    };
  }, []);

  const signIn = async (email: string, password: string) => {
    console.log(`[DEBUG] signIn: Attempting to sign in user: ${email}`);
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      console.log("[DEBUG] signIn: supabase.auth.signInWithPassword response:", { data, error });

      if (error) {
        console.error(`[DEBUG] signIn: Error during sign in for ${email}: `, error);
        return { error };
      }

      // The auth state change listener will handle loading the user data
      // We don't need to do it here as it causes duplicate loading
      console.log(`[DEBUG] signIn: Sign in successful for ${email}. Auth state change will handle user data loading.`);
      return { error: null };
    } catch (error) {
      console.error(`[DEBUG] signIn: Unexpected error during sign in for ${email}: `, error);
      return { error: error as Error };
    }
  };

  const signUp = async (email: string, password: string, fullName: string, organizationName?: string) => {
    console.log(`[DEBUG] AuthContext.signUp: Called with:`, { email, fullName, organizationName });
    try {
      // First create the auth user
      console.log(`[DEBUG] AuthContext.signUp: Attempting to create auth user for ${email}`);
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            full_name: fullName,
          }
        }
      });

      console.log('[DEBUG] AuthContext.signUp: supabase.auth.signUp response:', { authData, authError });
      if (authError || !authData.user) {
        console.error(`[DEBUG] AuthContext.signUp: Error creating auth user for ${email} or no user data returned. Error: `, authError);
        return { error: authError };
      }
      console.log(`[DEBUG] AuthContext.signUp: Auth user created successfully for ${email}. User ID: ${authData.user.id}`);

      // Create or find organization
      let orgId: string;
      console.log(`[DEBUG] AuthContext.signUp: Determining organization for ${email}. OrganizationName: ${organizationName}`);

      if (organizationName) {
        // Create new organization
        console.log(`[DEBUG] AuthContext.signUp: Creating new organization: ${organizationName}`);
        const { data: orgData, error: orgError } = await supabase
          .from('organizations')
          .insert({
            name: organizationName,
            country_code: 'US', // Default, should be configurable
            settings: {},
            features: {
              calling: true,
              events: true,
              imports: true,
              groups: true,
              pathways: true
            }
          })
          .select()
          .single()

        console.log('[DEBUG] AuthContext.signUp: Create organization response:', { orgData, orgError });
        if (orgError || !orgData) {
          console.error(`[DEBUG] AuthContext.signUp: Error creating organization ${organizationName} or no org data returned. Error: `, orgError);
          return { error: orgError };
        }
        orgId = orgData.id;
        console.log(`[DEBUG] AuthContext.signUp: New organization created. Name: ${organizationName}, ID: ${orgId}`);
      } else {
        // For now, assign to the demo organization if no org specified
        // In production, this would be handled differently
        console.log('[DEBUG] AuthContext.signUp: No organizationName provided. Looking for existing organization (demo).');
        const { data: orgs, error: orgError } = await supabase
          .from('organizations')
          .select('id')
          .limit(1)
          .single()
        
        console.log('[DEBUG] AuthContext.signUp: Find existing organization response:', { orgs, orgError });
        if (orgError || !orgs) {
          console.error('[DEBUG] AuthContext.signUp: Error finding existing organization or no orgs found. Error: ', orgError);
          return { error: orgError || new Error('No organization available') };
        }
        orgId = orgs.id;
        console.log(`[DEBUG] AuthContext.signUp: Using existing organization. ID: ${orgId}`);
      }

      // Create user profile
      console.log(`[DEBUG] AuthContext.signUp: Creating user profile for ${email} with orgId: ${orgId}`);
      const { data: profileData, error: profileError } = await supabase
        .from('users')
        .insert({
          id: authData.user.id,
          email,
          full_name: fullName,
          organization_id: orgId,
          role: organizationName ? 'admin' : 'ringer', // Admin if creating new org
          settings: {},
        })
        .select()

      console.log('[DEBUG] AuthContext.signUp: Create user profile response:', { profileData, profileError });
      if (profileError) {
        console.error(`[DEBUG] AuthContext.signUp: Error creating user profile for ${email}. Error: `, profileError);
        // If profile creation fails, we should clean up the auth user
        // For now, just return the error
        return { error: profileError };
      }
      console.log(`[DEBUG] AuthContext.signUp: User profile created successfully for ${email}.`, profileData);

      // In development, we can try to sign in immediately
      // In production with email confirmation required, this might fail
      console.log('[DEBUG] AuthContext.signUp: Attempting auto sign-in after signup...');
      
      // Small delay to ensure the user is created in the auth system
      console.log("[DEBUG] AuthContext.signUp: Waiting 1s before attempting auto sign-in...");
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log("[DEBUG] AuthContext.signUp: Wait complete. Attempting signInWithPassword.");
      
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email,
        password
      });

      if (signInError) {
        console.log(`[DEBUG] AuthContext.signUp: Auto sign-in not available for ${email} (email confirmation may be required): `, signInError.message);
        // Return success anyway - the signup itself was successful
        // User will need to confirm email and then sign in manually
      } else {
        console.log(`[DEBUG] AuthContext.signUp: Auto sign-in successful for ${email}!`);
        // The auth state change listener will handle updating the state
      }

      console.log(`[DEBUG] AuthContext.signUp: SignUp process completed for ${email}.`);
      return { error: null };
    } catch (error) {
      console.error(`[DEBUG] AuthContext.signUp: Unexpected error during signUp for ${email}: `, error);
      return { error: error as Error };
    }
  };

  const signOut = async () => {
    console.log("[DEBUG] signOut: Starting sign out process.");
    // Clear all local storage
    console.log("[DEBUG] signOut: Clearing localStorage.");
    localStorage.clear();
    
    // Clear all session storage
    console.log("[DEBUG] signOut: Clearing sessionStorage.");
    sessionStorage.clear();
    
    // Clear IndexedDB data if it exists
    if ('indexedDB' in window) {
      console.log("[DEBUG] signOut: Attempting to clear IndexedDB.");
      try {
        const databases = await indexedDB.databases();
        console.log("[DEBUG] signOut: IndexedDB databases found:", databases);
        databases.forEach(db => {
          if (db.name) {
            console.log(`[DEBUG] signOut: Deleting IndexedDB database: ${db.name}`);
            indexedDB.deleteDatabase(db.name);
          }
        });
      } catch (e) {
        console.warn("[DEBUG] signOut: Error listing IndexedDB databases (some browsers don't support). Attempting to delete known DB. Error:", e);
        // Some browsers don't support indexedDB.databases()
        // Try to delete known databases
        try {
          console.log("[DEBUG] signOut: Deleting known IndexedDB database: contact-manager-db");
          indexedDB.deleteDatabase('contact-manager-db');
        } catch (err) {
          console.error('[DEBUG] signOut: Error clearing known IndexedDB:', err);
        }
      }
    } else {
      console.log("[DEBUG] signOut: IndexedDB not in window.");
    }
    
    // Sign out from Supabase
    console.log("[DEBUG] signOut: Calling supabase.auth.signOut().");
    await supabase.auth.signOut();
    console.log("[DEBUG] signOut: supabase.auth.signOut() completed.");
    
    // Clear state
    console.log("[DEBUG] signOut: Clearing React state (user, profile, organization, session).");
    setUser(null);
    setProfile(null);
    setOrganization(null);
    setSession(null);
    
    // Clear any cached data in service worker
    if ('caches' in window) {
      console.log("[DEBUG] signOut: Attempting to clear service worker caches.");
      const cacheNames = await caches.keys();
      console.log("[DEBUG] signOut: Service worker cache names found:", cacheNames);
      await Promise.all(
        cacheNames.map(cacheName => {
          console.log(`[DEBUG] signOut: Deleting cache: ${cacheName}`);
          return caches.delete(cacheName);
        })
      );
      console.log("[DEBUG] signOut: Service worker caches cleared.");
    } else {
      console.log("[DEBUG] signOut: Caches not in window.");
    }
    console.log("[DEBUG] signOut: Sign out process completed.");
  };

  const updateProfile = async (updates: Partial<UserProfile>) => {
    console.log("[DEBUG] updateProfile: Called with updates:", updates);
    if (!user) {
      console.warn("[DEBUG] updateProfile: No user logged in. Cannot update profile.");
      return { error: new Error('No user logged in') };
    }
    console.log(`[DEBUG] updateProfile: User ${user.id} is logged in. Proceeding with update.`);

    try {
      console.log(`[DEBUG] updateProfile: Calling supabase.from('users').update for user ID: ${user.id}`);
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', user.id)
        .select()
        .single()

      console.log("[DEBUG] updateProfile: supabase.from('users').update response:", { data, error });

      if (error) {
        console.error(`[DEBUG] updateProfile: Error updating profile for user ID: ${user.id}. Error:`, error);
        return { error };
      }

      setProfile(data);
      console.log(`[DEBUG] updateProfile: Profile updated successfully for user ID: ${user.id}. New profile data:`, data);
      return { error: null };
    } catch (error) {
      console.error(`[DEBUG] updateProfile: Unexpected error updating profile for user ID: ${user.id}. Error:`, error);
      return { error: error as Error };
    }
  };

  const value = {
    user,
    profile,
    organization,
    session,
    loading,
    signIn,
    signUp,
    signOut,
    updateProfile,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    console.error("[DEBUG] useAuth: hook used outside of AuthProvider. This will throw an error.");
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}